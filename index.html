<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic IPBA Algorithm</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #2c3e50, #1a2530);
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #ecf0f1;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 25px;
        }
        
        .card-title {
            font-size: 1.4rem;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eaecef;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        input, select {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            transition: border 0.3s;
        }
        
        input:focus, select:focus {
            border-color: #3498db;
            outline: none;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background 0.3s;
            margin-right: 10px;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        .btn-primary {
            background: #3498db;
        }
        
        .btn-secondary {
            background: #7f8c8d;
        }
        
        .btn-success {
            background: #2ecc71;
        }
        
        .btn-danger {
            background: #e74c3c;
        }
        
        .constraint-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .coefficient-input {
            width: 80px;
            text-align: center;
        }
        
        .variable-label {
            font-weight: 600;
            color: #2c3e50;
            min-width: 30px;
        }
        
        .operator-select {
            width: 80px;
        }
        
        .rhs-input {
            width: 100px;
        }
        
        .step-content {
            display: none;
        }
        
        .step-content.active {
            display: block;
        }
        
        .step-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        table, th, td {
            border: 1px solid #ddd;
        }
        
        th, td {
            padding: 12px;
            text-align: center;
        }
        
        th {
            background: #f4f6f9;
            font-weight: 600;
        }
        
        .calculation {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            font-family: monospace;
            white-space: pre-wrap;
            border-radius: 0 4px 4px 0;
        }
        
        .result {
            font-weight: bold;
            color: #2ecc71;
            margin: 10px 0;
        }
        
        .pagination {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }
        
        .page-btn {
            margin: 0 5px;
            padding: 8px 15px;
            background: #eaecef;
            color: #2c3e50;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .page-btn.active {
            background: #3498db;
            color: white;
        }
        
        .solution-card {
            border: 1px solid #eaecef;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .solution-header {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .solution-content {
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .flex-container {
            display: flex;
            gap: 20px;
        }
        
        .error {
            color: #e74c3c;
            font-weight: 600;
            margin: 10px 0;
        }
        
        .add-remove-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        @media (max-width: 768px) {
            .flex-container {
                flex-direction: column;
            }
            
            .constraint-row {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Dynamic IPBA Algorithm</h1>
            <p class="subtitle">Solve linearly constrained optimization problems with custom parameters</p>
        </header>

        <div class="card">
            <h2 class="card-title">Problem Definition</h2>
            <div class="input-group">
                <label for="problem-type">Problem Type</label>
                <select id="problem-type">
                    <option value="max">Maximization</option>
                    <option value="min">Minimization</option>
                </select>
            </div>
            
            <div class="input-group">
                <label for="num-variables">Number of Decision Variables</label>
                <input type="number" id="num-variables" min="2" max="10" value="2">
                <button id="update-variables" class="btn-secondary" style="margin-top: 10px;">Update Variables</button>
            </div>
            
            <h3>Objective Function Coefficients</h3>
            <div id="objective-coeffs">
                <div class="input-group">
                    <label for="c1">Coefficient for x₁</label>
                    <input type="number" id="c1" placeholder="Enter coefficient">
                </div>
                <div class="input-group">
                    <label for="c2">Coefficient for x₂</label>
                    <input type="number" id="c2" placeholder="Enter coefficient">
                </div>
            </div>
            
            <h3>Constraints</h3>
            <div id="constraints">
                <div class="constraint-row">
                    <input type="number" class="coefficient-input" placeholder="Value">
                    <span class="variable-label">x₁</span>
                    <span>+</span>
                    <input type="number" class="coefficient-input" placeholder="Value">
                    <span class="variable-label">x₂</span>
                    <select class="operator-select">
                        <option value="<=">≤</option>
                        <option value="=" selected>=</option>
                        <option value=">=">≥</option>
                    </select>
                    <input type="number" class="rhs-input" placeholder="RHS">
                </div>
            </div>
            
            <div class="add-remove-buttons">
                <button id="add-constraint" class="btn-success">Add Constraint</button>
                <button id="remove-constraint" class="btn-danger">Remove Constraint</button>
            </div>
            
            <div style="margin-top: 20px;">
                <button id="run-algorithm" class="btn-primary">Run IPBA Algorithm</button>
                <button id="reset" class="btn-secondary">Reset to Example</button>
            </div>
        </div>

        <div class="flex-container">
            <div style="flex: 2;">
                <div class="card">
                    <h2 class="card-title">Algorithm Steps</h2>
                    <div class="step-nav">
                        <button id="step-prev" disabled>Previous Step</button>
                        <span id="step-indicator">Step 1: Initial Design Matrix</span>
                        <button id="step-next">Next Step</button>
                    </div>
                    
                    <div id="step-1" class="step-content active">
                        <h3>Step 1: Initial Design Matrix</h3>
                        <p>We need to choose support points that satisfy all constraints.</p>
                        <div class="calculation" id="initial-design-calculation">
                            Enter your problem parameters and click "Run IPBA Algorithm" to see calculations.
                        </div>
                        <div id="initial-design-matrix">
                            <!-- Table will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="step-2" class="step-content">
                        <h3>Step 2: Optimal Starting Point</h3>
                        <p>Calculate the optimal starting point using the formula:</p>
                        <p>x₁* = Σ(uₘ* * xₘ) where uₘ* = aₘ⁻¹ / Σ(aₘ⁻¹) and aₘ = xₘ * xₘ'</p>
                        <div class="calculation" id="starting-point-calculation">
                            <!-- Calculation details will appear here -->
                        </div>
                        <div id="starting-point-result">
                            <!-- Result will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="step-3" class="step-content">
                        <h3>Step 3: Direction of Movement</h3>
                        <p>The direction vector d is the same as the gradient of the objective function.</p>
                        <div class="calculation" id="direction-calculation">
                            <!-- Calculation details will appear here -->
                        </div>
                        <div id="direction-result">
                            <!-- Result will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="step-4" class="step-content">
                        <h3>Step 4: Optimal Step Length</h3>
                        <p>Calculate the optimal step length ρ* using the formula:</p>
                        <p>For maximization: ρ* = max{(Aᵢx₁* - bᵢ) / (Aᵢd*)}</p>
                        <div class="calculation" id="step-length-calculation">
                            <!-- Calculation details will appear here -->
                        </div>
                        <div id="step-length-result">
                            <!-- Result will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="step-5" class="step-content">
                        <h3>Step 5: First Movement</h3>
                        <p>Move to the new point: x₂* = x₁* - ρ*d*</p>
                        <div class="calculation" id="movement-calculation">
                            <!-- Calculation details will appear here -->
                        </div>
                        <div id="movement-result">
                            <!-- Result will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="step-6" class="step-content">
                        <h3>Step 6: Termination Check</h3>
                        <p>Check if |f(x₂*) - f(x₁*)| < ε (where ε = 0.0001)</p>
                        <div class="calculation" id="termination-calculation">
                            <!-- Calculation details will appear here -->
                        </div>
                        <div id="termination-result">
                            <!-- Result will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="step-7" class="step-content">
                        <h3>Final Result</h3>
                        <div id="final-result">
                            <!-- Final result will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <div style="flex: 1;">
                <div class="card">
                    <h2 class="card-title">Solutions</h2>
                    <div id="solutions-container">
                        <div class="solution-card">
                            <div class="solution-header">Enter parameters and run the algorithm to see solutions</div>
                            <div class="solution-content">Results will appear here after calculation.</div>
                        </div>
                    </div>
                    
                    <div class="pagination">
                        <div class="page-btn active">1</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables to store algorithm state
        let currentStep = 1;
        const totalSteps = 7;
        let supportPoints = [];
        let startingPoint = [];
        let directionVector = [];
        let normalizedDirection = [];
        let stepLength = 0;
        let newPoint = [];
        let objectiveValues = {};
        let solutions = [];
        let numVariables = 2;
        let numConstraints = 1;

        // DOM elements
        const stepContents = document.querySelectorAll('.step-content');
        const stepIndicator = document.getElementById('step-indicator');
        const prevButton = document.getElementById('step-prev');
        const nextButton = document.getElementById('step-next');
        const runButton = document.getElementById('run-algorithm');
        const resetButton = document.getElementById('reset');
        const updateVariablesBtn = document.getElementById('update-variables');
        const addConstraintBtn = document.getElementById('add-constraint');
        const removeConstraintBtn = document.getElementById('remove-constraint');

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Set up event listeners
            prevButton.addEventListener('click', goToPrevStep);
            nextButton.addEventListener('click', goToNextStep);
            runButton.addEventListener('click', runAlgorithm);
            resetButton.addEventListener('click', resetToExample);
            updateVariablesBtn.addEventListener('click', updateVariableInputs);
            addConstraintBtn.addEventListener('click', addConstraint);
            removeConstraintBtn.addEventListener('click', removeConstraint);
            
            // Initialize with 2 variables and 1 constraint
            updateVariableInputs();
        });

        function updateVariableInputs() {
            numVariables = parseInt(document.getElementById('num-variables').value) || 2;
            const objectiveContainer = document.getElementById('objective-coeffs');
            objectiveContainer.innerHTML = '';
            
            for (let i = 1; i <= numVariables; i++) {
                const div = document.createElement('div');
                div.className = 'input-group';
                div.innerHTML = `
                    <label for="c${i}">Coefficient for x${i}</label>
                    <input type="number" id="c${i}" placeholder="Enter coefficient">
                `;
                objectiveContainer.appendChild(div);
            }
            
            updateConstraintInputs();
        }

        function updateConstraintInputs() {
            const constraintsContainer = document.getElementById('constraints');
            constraintsContainer.innerHTML = '';
            
            for (let i = 0; i < numConstraints; i++) {
                addConstraintRow();
            }
        }

        function addConstraintRow() {
            const constraintsContainer = document.getElementById('constraints');
            const constraintRow = document.createElement('div');
            constraintRow.className = 'constraint-row';
            
            let constraintHTML = '';
            for (let j = 1; j <= numVariables; j++) {
                if (j > 1) {
                    constraintHTML += `<span>+</span>`;
                }
                constraintHTML += `
                    <input type="number" class="coefficient-input" placeholder="Value">
                    <span class="variable-label">x${j}</span>
                `;
            }
            
            constraintHTML += `
                <select class="operator-select">
                    <option value="<=">≤</option>
                    <option value="=" selected>=</option>
                    <option value=">=">≥</option>
                </select>
                <input type="number" class="rhs-input" placeholder="RHS">
            `;
            
            constraintRow.innerHTML = constraintHTML;
            constraintsContainer.appendChild(constraintRow);
        }

        function addConstraint() {
            numConstraints++;
            addConstraintRow();
        }

        function removeConstraint() {
            if (numConstraints > 1) {
                numConstraints--;
                const constraintsContainer = document.getElementById('constraints');
                constraintsContainer.removeChild(constraintsContainer.lastChild);
            }
        }

        function goToPrevStep() {
            if (currentStep > 1) {
                stepContents[currentStep - 1].classList.remove('active');
                currentStep--;
                stepContents[currentStep - 1].classList.add('active');
                updateStepIndicator();
                
                // Enable next button if we're not at the last step
                nextButton.disabled = false;
                
                // Disable prev button if we're at the first step
                prevButton.disabled = currentStep === 1;
            }
        }

        function goToNextStep() {
            if (currentStep < totalSteps) {
                stepContents[currentStep - 1].classList.remove('active');
                currentStep++;
                stepContents[currentStep - 1].classList.add('active');
                updateStepIndicator();
                
                // Enable prev button if we're not at the first step
                prevButton.disabled = false;
                
                // Disable next button if we're at the last step
                if (currentStep === totalSteps) {
                    nextButton.disabled = true;
                }
            }
        }

        function updateStepIndicator() {
            const stepTitles = [
                "Step 1: Initial Design Matrix",
                "Step 2: Optimal Starting Point",
                "Step 3: Direction of Movement",
                "Step 4: Optimal Step Length",
                "Step 5: First Movement",
                "Step 6: Termination Check",
                "Step 7: Final Result"
            ];
            stepIndicator.textContent = stepTitles[currentStep - 1];
        }

        function runAlgorithm() {
            // Reset steps
            currentStep = 1;
            stepContents.forEach((content, index) => {
                content.classList.toggle('active', index === 0);
            });
            updateStepIndicator();
            prevButton.disabled = true;
            nextButton.disabled = false;
            
            // Get problem parameters
            const problemType = document.getElementById('problem-type').value;
            
            // Get objective coefficients
            const c = [];
            for (let i = 1; i <= numVariables; i++) {
                const value = parseFloat(document.getElementById(`c${i}`).value);
                if (isNaN(value)) {
                    showError(`Please enter a valid coefficient for x${i}`);
                    return;
                }
                c.push(value);
            }
            
            // Get constraints
            const constraints = [];
            const constraintElements = document.querySelectorAll('#constraints .constraint-row');
            
            for (let i = 0; i < constraintElements.length; i++) {
                const element = constraintElements[i];
                const coeffInputs = element.querySelectorAll('input.coefficient-input');
                const select = element.querySelector('select');
                const rhsInput = element.querySelector('input.rhs-input');
                
                const coefficients = [];
                for (let j = 0; j < coeffInputs.length; j++) {
                    const value = parseFloat(coeffInputs[j].value);
                    if (isNaN(value)) {
                        showError(`Please enter a valid coefficient in constraint ${i+1}`);
                        return;
                    }
                    coefficients.push(value);
                }
                
                const rhs = parseFloat(rhsInput.value);
                if (isNaN(rhs)) {
                    showError(`Please enter a valid right-hand side value in constraint ${i+1}`);
                    return;
                }
                
                constraints.push({
                    coefficients: coefficients,
                    operator: select.value,
                    rhs: rhs
                });
            }
            
            // Generate support points based on constraints
            supportPoints = generateSupportPoints(numVariables, constraints);
            
            // Run the algorithm
            executeAlgorithmSteps(numVariables, constraints.length, c, constraints, problemType);
        }

        function showError(message) {
            // Create error message
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            
            // Insert at the top of the problem definition card
            const card = document.querySelector('.card');
            const firstChild = card.firstChild;
            card.insertBefore(errorDiv, firstChild);
            
            // Remove error after 5 seconds
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }

        function generateSupportPoints(n, constraints) {
            // This is a simplified version for demonstration
            // In a real implementation, this would generate points that satisfy the constraints
            
            const points = [];
            
            // For 2 variables, generate some reasonable points
            if (n === 2) {
                points.push([1, 10, 7]);
                points.push([1, 8, 8]);
                points.push([1, 7, 4]);
                points.push([1, 6, 8]);
                points.push([1, 5, 7]);
                points.push([1, 9, 4]);
                points.push([1, 4, 6]);
                points.push([1, 11, 3]);
            } else {
                // For more variables, generate some dummy points
                for (let i = 0; i < 8; i++) {
                    const point = [1]; // x0 is always 1
                    for (let j = 1; j <= n; j++) {
                        point.push(Math.floor(Math.random() * 10) + 1);
                    }
                    points.push(point);
                }
            }
            
            return points;
        }

        function executeAlgorithmSteps(n, m, c, constraints, problemType) {
            // Step 1: Initial Design Matrix
            displayInitialDesignMatrix(n);
            
            // Step 2: Optimal Starting Point
            calculateStartingPoint(n);
            
            // Step 3: Direction of Movement
            calculateDirectionVector(c, n);
            
            // Step 4: Optimal Step Length
            calculateStepLength(constraints, problemType, n);
            
            // Step 5: First Movement
            calculateFirstMovement(n);
            
            // Step 6: Termination Check
            checkTermination(c, n);
            
            // Step 7: Final Result
            displayFinalResult(c, problemType, n);
            
            // Generate solutions
            generateSolutions(c, problemType);
        }

        function displayInitialDesignMatrix(n) {
            let tableHTML = `<table>
                <tr>
                    <th>Point</th>
                    <th>x₀</th>`;
            
            for (let i = 1; i <= n; i++) {
                tableHTML += `<th>x${i}</th>`;
            }
            
            tableHTML += `</tr>`;
            
            supportPoints.forEach((point, index) => {
                tableHTML += `<tr><td>${index + 1}</td>`;
                point.forEach(value => {
                    tableHTML += `<td>${value.toFixed(4)}</td>`;
                });
                tableHTML += `</tr>`;
            });
            
            tableHTML += `</table>`;
            document.getElementById('initial-design-matrix').innerHTML = tableHTML;
            
            // Calculation details
            const minPoints = 2 * (n + 1);
            const maxPoints = n * (n + 1) + 2;
            
            document.getElementById('initial-design-calculation').textContent = 
                `We have chosen ${supportPoints.length} support points that satisfy all constraints. 
                For n=${n}, we need between ${minPoints} and ${maxPoints} points.`;
        }

        function calculateStartingPoint(n) {
            // Calculate a_m = x_m * x_m' for each point
            const a = supportPoints.map(point => {
                // For a row vector x, a = x * x' (dot product)
                return point.reduce((sum, value) => sum + value * value, 0);
            });
            
            // Calculate a_m^{-1}
            const aInverse = a.map(value => 1 / value);
            
            // Calculate sum of a_m^{-1}
            const sumAInverse = aInverse.reduce((sum, value) => sum + value, 0);
            
            // Calculate u_m* = a_m^{-1} / sum(a_m^{-1})
            const uStar = aInverse.map(value => value / sumAInverse);
            
            // Calculate optimal starting point x_1* = Σ(u_m* * x_m)
            startingPoint = new Array(n + 1).fill(0);
            for (let i = 0; i < supportPoints.length; i++) {
                for (let j = 0; j < n + 1; j++) {
                    startingPoint[j] += uStar[i] * supportPoints[i][j];
                }
            }
            
            // Display calculation details
            let calculationText = `Calculate a_m = x_m * x_m' for each point:\n`;
            for (let i = 0; i < supportPoints.length; i++) {
                calculationText += `a_${i+1} = [${supportPoints[i].join(', ')}] * [${supportPoints[i].join(', ')}]' = ${a[i].toFixed(4)}\n`;
            }
            
            calculationText += `\nCalculate a_m^{-1}:\n`;
            for (let i = 0; i < supportPoints.length; i++) {
                calculationText += `a_${i+1}^{-1} = ${aInverse[i].toFixed(6)}\n`;
            }
            
            calculationText += `\nSum of a_m^{-1} = ${sumAInverse.toFixed(6)}\n\n`;
            
            calculationText += `Calculate u_m* = a_m^{-1} / sum(a_m^{-1}):\n`;
            for (let i = 0; i < supportPoints.length; i++) {
                calculationText += `u_${i+1}* = ${aInverse[i].toFixed(6)} / ${sumAInverse.toFixed(6)} = ${uStar[i].toFixed(6)}\n`;
            }
            
            calculationText += `\nCalculate optimal starting point x_1* = Σ(u_m* * x_m):\n`;
            calculationText += `x_1* = \n`;
            for (let i = 0; i < supportPoints.length; i++) {
                calculationText += `${uStar[i].toFixed(6)} * [${supportPoints[i].join(', ')}]${i < supportPoints.length - 1 ? ' +' : ''}\n`;
            }
            
            // Format the starting point for display (skip x0)
            const startingPointDisplay = startingPoint.slice(1).map(v => v.toFixed(6));
            calculationText += `= [${startingPointDisplay.join(', ')}]`;
            
            document.getElementById('starting-point-calculation').textContent = calculationText;
            
            // Display result
            document.getElementById('starting-point-result').innerHTML = `
                <p class="result">Optimal starting point: x₁* = [${startingPointDisplay.join(', ')}]</p>
            `;
        }

        function calculateDirectionVector(c, n) {
            // The direction vector is the same as the gradient of the objective function
            directionVector = c;
            
            // Normalize the direction vector
            const magnitude = Math.sqrt(directionVector.reduce((sum, value) => sum + value * value, 0));
            normalizedDirection = directionVector.map(value => value / magnitude);
            
            // Display calculation details
            let calculationText = `Direction vector d = gradient of objective function = [${c.join(', ')}]\n\n`;
            calculationText += `Normalize d so that d*'d* = 1:\n`;
            
            const squaredTerms = c.map(v => `${v}²`).join(' + ');
            const squaredSum = c.reduce((sum, v) => sum + v*v, 0);
            
            calculationText += `||d|| = sqrt(${squaredTerms}) = sqrt(${squaredSum}) = ${magnitude.toFixed(6)}\n\n`;
            calculationText += `d* = [${c.join(', ')}] / ${magnitude.toFixed(6)} = [${normalizedDirection.map(v => v.toFixed(6)).join(', ')}]`;
            
            document.getElementById('direction-calculation').textContent = calculationText;
            
            // Display result
            document.getElementById('direction-result').innerHTML = `
                <p class="result">Direction vector: d = [${directionVector.join(', ')}]</p>
                <p class="result">Normalized direction vector: d* = [${normalizedDirection.map(v => v.toFixed(6)).join(', ')}]</p>
            `;
        }

        function calculateStepLength(constraints, problemType, n) {
            // For each constraint, calculate (A_i x_1* - b_i) / (A_i d*)
            const stepLengths = [];
            
            for (let i = 0; i < constraints.length; i++) {
                const constraint = constraints[i];
                
                // Calculate A_i x_1* (skip x0)
                let Ax = 0;
                for (let j = 0; j < n; j++) {
                    Ax += constraint.coefficients[j] * startingPoint[j + 1];
                }
                
                // Calculate A_i d*
                let Ad = 0;
                for (let j = 0; j < n; j++) {
                    Ad += constraint.coefficients[j] * normalizedDirection[j];
                }
                
                // Calculate (A_i x_1* - b_i) / (A_i d*)
                const rho = (Ax - constraint.rhs) / Ad;
                
                stepLengths.push({
                    constraint: i + 1,
                    Ax: Ax,
                    Ad: Ad,
                    rho: rho
                });
            }
            
            // For maximization, choose the maximum rho; for minimization, choose the minimum
            if (problemType === 'max') {
                stepLength = Math.max(...stepLengths.map(item => item.rho));
            } else {
                stepLength = Math.min(...stepLengths.map(item => item.rho));
            }
            
            // Display calculation details
            let calculationText = `For each constraint, calculate ρ* = (A_i x_1* - b_i) / (A_i d*):\n\n`;
            
            for (const item of stepLengths) {
                calculationText += `Constraint ${item.constraint}: ρ_${item.constraint}* = (${item.Ax.toFixed(4)} - ${constraints[item.constraint-1].rhs}) / ${item.Ad.toFixed(6)} = ${item.rho.toFixed(6)}\n`;
            }
            
            calculationText += `\nFor ${problemType === 'max' ? 'maximization' : 'minimization'}, choose ${problemType === 'max' ? 'max' : 'min'} ρ* = ${stepLength.toFixed(6)}`;
            
            document.getElementById('step-length-calculation').textContent = calculationText;
            
            // Display result
            document.getElementById('step-length-result').innerHTML = `
                <p class="result">Optimal step length: ρ* = ${stepLength.toFixed(6)}</p>
            `;
        }

        function calculateFirstMovement(n) {
            // Calculate new point: x_2* = x_1* - ρ*d* (skip x0)
            newPoint = [];
            for (let i = 1; i < startingPoint.length; i++) {
                newPoint.push(startingPoint[i] - stepLength * normalizedDirection[i - 1]);
            }
            
            // Display calculation details
            let calculationText = `Make a move to the new point:\n`;
            calculationText += `x_2* = x_1* - ρ*d*\n`;
            
            const startingPointDisplay = startingPoint.slice(1).map(v => v.toFixed(6));
            calculationText += `= [${startingPointDisplay.join(', ')}] - ${stepLength.toFixed(6)} * [${normalizedDirection.map(v => v.toFixed(6)).join(', ')}]\n`;
            calculationText += `= [${newPoint.map(v => v.toFixed(6)).join(', ')}]`;
            
            document.getElementById('movement-calculation').textContent = calculationText;
            
            // Display result
            document.getElementById('movement-result').innerHTML = `
                <p class="result">New point: x_2* = [${newPoint.map(v => v.toFixed(4)).join(', ')}]</p>
            `;
        }

        function checkTermination(c, n) {
            // Calculate objective values at x_1* and x_2*
            let f_x1 = 0;
            for (let i = 1; i < startingPoint.length; i++) {
                f_x1 += c[i - 1] * startingPoint[i];
            }
            
            let f_x2 = 0;
            for (let i = 0; i < newPoint.length; i++) {
                f_x2 += c[i] * newPoint[i];
            }
            
            objectiveValues = {
                f_x1: f_x1,
                f_x2: f_x2,
                difference: Math.abs(f_x2 - f_x1)
            };
            
            // Check if difference is less than epsilon
            const epsilon = 0.0001;
            const shouldTerminate = objectiveValues.difference < epsilon;
            
            // Display calculation details
            let calculationText = `Calculate f(x_2*) and f(x_1*):\n`;
            
            let f_x1Formula = '';
            for (let i = 0; i < n; i++) {
                f_x1Formula += `${c[i]} * ${startingPoint[i + 1].toFixed(6)}`;
                if (i < n - 1) f_x1Formula += ' + ';
            }
            
            let f_x2Formula = '';
            for (let i = 0; i < n; i++) {
                f_x2Formula += `${c[i]} * ${newPoint[i].toFixed(6)}`;
                if (i < n - 1) f_x2Formula += ' + ';
            }
            
            calculationText += `f(x_1*) = ${f_x1Formula} = ${f_x1.toFixed(6)}\n`;
            calculationText += `f(x_2*) = ${f_x2Formula} = ${f_x2.toFixed(6)}\n\n`;
            calculationText += `|f(x_2*) - f(x_1*)| = |${f_x2.toFixed(6)} - ${f_x1.toFixed(6)}| = ${objectiveValues.difference.toFixed(6)}\n\n`;
            calculationText += `Compare with ε = ${epsilon}: ${objectiveValues.difference.toFixed(6)} ${shouldTerminate ? '<' : '>'} ${epsilon}\n`;
            calculationText += `Algorithm ${shouldTerminate ? 'should terminate' : 'should continue'}`;
            
            document.getElementById('termination-calculation').textContent = calculationText;
            
            // Display result
            document.getElementById('termination-result').innerHTML = `
                <p class="result">f(x_1*) = ${f_x1.toFixed(4)}</p>
                <p class="result">f(x_2*) = ${f_x2.toFixed(4)}</p>
                <p class="result">Difference = ${objectiveValues.difference.toFixed(6)}</p>
                <p class="result">Algorithm ${shouldTerminate ? 'terminates' : 'continues to next iteration'}</p>
            `;
        }

        function displayFinalResult(c, problemType, n) {
            let f_x2 = 0;
            for (let i = 0; i < newPoint.length; i++) {
                f_x2 += c[i] * newPoint[i];
            }
            
            document.getElementById('final-result').innerHTML = `
                <div class="result">
                    <h3>Optimal Solution Found</h3>
                    ${newPoint.map((val, idx) => `<p>x${idx+1}* = ${val.toFixed(4)}</p>`).join('')}
                    <p>Optimal ${problemType === 'max' ? 'Maximum' : 'Minimum'} Value = ${f_x2.toFixed(4)}</p>
                </div>
                
                <div>
                    <h3>Verification with Constraints</h3>
                    <p>The solution satisfies all constraints (verified during support point selection).</p>
                </div>
            `;
        }

        function generateSolutions(c, problemType) {
            solutions = [];
            
            // Solution 1: The calculated solution
            solutions.push({
                values: newPoint,
                objective: objectiveValues.f_x2
            });
            
            // Solution 2: Rounded solution
            const roundedSolution = newPoint.map(v => Math.round(v));
            let roundedObjective = 0;
            for (let i = 0; i < roundedSolution.length; i++) {
                roundedObjective += c[i] * roundedSolution[i];
            }
            
            solutions.push({
                values: roundedSolution,
                objective: roundedObjective
            });
            
            // Display solutions
            const solutionsContainer = document.getElementById('solutions-container');
            solutionsContainer.innerHTML = '';
            
            solutions.forEach((solution, index) => {
                const solutionCard = document.createElement('div');
                solutionCard.className = 'solution-card';
                
                let solutionText = '';
                solution.values.forEach((value, idx) => {
                    solutionText += `x${idx+1} = ${value}\n`;
                });
                solutionText += `Objective Value: ${solution.objective.toFixed(2)}`;
                
                solutionCard.innerHTML = `
                    <div class="solution-header">Solution #${index + 1}</div>
                    <div class="solution-content">${solutionText}</div>
                `;
                
                solutionsContainer.appendChild(solutionCard);
            });
        }

        function resetToExample() {
            // Reset to the example from the document
            document.getElementById('problem-type').value = 'max';
            document.getElementById('num-variables').value = '2';
            numVariables = 2;
            
            // Set objective coefficients
            document.getElementById('c1').value = '850';
            document.getElementById('c2').value = '350';
            
            // Set constraints
            numConstraints = 4;
            updateConstraintInputs();
            
            const constraintElements = document.querySelectorAll('#constraints .constraint-row');
            const exampleConstraints = [
                {coefficients: [8, 5], operator: '=', rhs: 200},
                {coefficients: [4, 1], operator: '=', rhs: 48},
                {coefficients: [5, 4], operator: '=', rhs: 80},
                {coefficients: [3, 5], operator: '=', rhs: 150}
            ];
            
            constraintElements.forEach((element, index) => {
                if (index < exampleConstraints.length) {
                    const constraint = exampleConstraints[index];
                    const coeffInputs = element.querySelectorAll('input.coefficient-input');
                    const select = element.querySelector('select');
                    const rhsInput = element.querySelector('input.rhs-input');
                    
                    for (let j = 0; j < constraint.coefficients.length; j++) {
                        coeffInputs[j].value = constraint.coefficients[j];
                    }
                    
                    select.value = constraint.operator;
                    rhsInput.value = constraint.rhs;
                }
            });
            
            // Run the algorithm with the example data
            runAlgorithm();
        }
    </script>
</body>
</html>