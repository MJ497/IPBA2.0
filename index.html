<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced IPBA Algorithm</title>
   <link rel="stylesheet" href="main.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Invariant Property-based Algorithm</h1>
            <h1>For</h1>
            <p class="subtitle">Solving Linearly constrained optimization Problems With Linear Objective Function.</p>
            <p class="subtitle">By Prof. Etukudo</p>
        </header>

        <div class="card">
            <h2 class="card-title">Problem Definition</h2>
            <div class="input-group">
                <label for="problem-type">Problem Type</label>
                <select id="problem-type">
                    <option value="max">Maximization</option>
                    <option value="min">Minimization</option>
                </select>
            </div>
            
            <div class="input-group">
                <label for="num-variables">Number of Decision Variables</label>
                <input type="number" id="num-variables" min="2" max="10" value="2">
                <button id="update-variables" class="btn-secondary" style="margin-top: 10px;">Update Variables</button>
            </div>
            
            <div class="input-group">
                <label for="num-constraints">Number of Constraints</label>
                <input type="number" id="num-constraints" min="1" max="20" value="4">
                <button id="update-constraints" class="btn-secondary" style="margin-top: 10px;">Update Constraints</button>
            </div>
            
            <!-- <div class="input-group">
                <label for="num-solutions">Number of Solutions to Generate</label>
                <input type="number" id="num-solutions" min="1" max="20" value="5">
            </div> -->
            
            <h3>Objective Function Coefficients</h3>
            <div id="objective-coeffs">
                <div class="input-group">
                    <label for="c1">Coefficient for x₁</label>
                    <input type="number" id="c1" placeholder="Enter coefficient">
                </div>
                <div class="input-group">
                    <label for="c2">Coefficient for x₂</label>
                    <input type="number" id="c2" placeholder="Enter coefficient">
                </div>
            </div>
            
            <h3>Constraints</h3>
            <div id="constraints">
                <!-- Constraints will be dynamically generated here -->
            </div>
            
            <h3>Support Points</h3>
            <div class="input-group">
                <label for="num-support-points">Number of Support Points (N)</label>
                <select id="num-support-points">
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8" selected>8</option>
                </select>
                <div id="support-points-range" class="calculation" style="margin-top: 10px;">
                    For n=2, the number of support points must be between 6 and 8.
                </div>
            </div>
            
            <div id="support-points-container">
                <!-- Support points inputs will be generated here -->
            </div>
            
            <div style="margin-top: 20px;">
                <button id="run-algorithm" class="btn-primary">Run IPBA Algorithm</button>
                <button id="clear-all" class="btn-danger">Clear All Fields</button>
                <!-- <button id="load-example" class="btn-success">Load Example</button> -->
            </div>
        </div>

        <div class="flex-container">
            <div style="flex: 2;">
                <div class="card">
                    <h2 class="card-title">Algorithm Steps</h2>
                    <div class="step-nav">
                        <button id="step-prev" disabled>Previous Step</button>
                        <span id="step-indicator">Step 1: Initial Design Matrix</span>
                        <button id="step-next">Next Step</button>
                    </div>
                    
                    <div id="step-1" class="step-content active">
                        <h3>Step 1: Initial Design Matrix</h3>
                        <p>We need to choose support points that satisfy all constraints.</p>
                        <div class="calculation" id="initial-design-calculation">
                            Enter your problem parameters and click "Run IPBA Algorithm" to see calculations.
                        </div>
                        <div id="initial-design-matrix">
                            <!-- Table will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="step-2" class="step-content">
                        <h3>Step 2: Optimal Starting Point</h3>
                        <p>Calculate the optimal starting point using the formula:</p>
                        <p>x₁* = Σ(uₘ*  x¹ₘ) where uₘ* > 0,  Σuₘ* = 1, uₘ* = aₘ⁻¹ / Σ(aₘ⁻¹) and aₘ = xₘ * xₘ' m=1,2...N</p>
                        <div class="calculation" id="starting-point-calculation">
                            <!-- Calculation details will appear here -->
                        </div>
                        <div id="starting-point-result">
                            <!-- Result will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="step-3" class="step-content">
                        <h3>Step 3: Direction of Movement</h3>
                        <p>The direction vector d is the same as the gradient of the objective function.</p>
                        <div class="calculation" id="direction-calculation">
                            <!-- Calculation details will appear here -->
                        </div>
                        <div id="direction-result">
                            <!-- Result will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="step-4" class="step-content">
                        <h3>Step 4: Optimal Step Length</h3>
                        <p>Calculate the optimal step length ρ* using the formula:</p>
                        <p>For maximization: ρ₁* = max{(Aᵢx₁* - bᵢ) / (Aᵢd*)}</p>
                        <div class="calculation" id="step-length-calculation">
                            <!-- Calculation details will appear here -->
                        </div>
                        <div id="step-length-result">
                            <!-- Result will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="step-5" class="step-content">
                        <h3>Step 5: First Movement</h3>
                        <p>Move to the point: x₂* = x₁* - ρ₁*d*</p>
                        <div class="calculation" id="movement-calculation">
                            <!-- Calculation details will appear here -->
                        </div>
                        <div id="movement-result">
                            <!-- Result will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="step-6" class="step-content">
                        <h3>Step 6: Termination Cateria</h3>
                        <p>Check if |f(x₂*) - f(x₁*)| < ε (where ε = 0.0001)</p>
                        <div class="calculation" id="termination-calculation">
                            <!-- Calculation details will appear here -->
                        </div>
                        <div id="termination-result">
                            <!-- Result will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="step-7" class="step-content">
                        <h3>Step 7: Second Movement </h3>
                        <p>If termination condition is not met, perform a second movement.</p>
                        <div class="calculation" id="second-movement-calculation">
                            <!-- Calculation details will appear here -->
                        </div>
                        <div id="second-movement-result">
                            <!-- Result will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="step-8" class="step-content">
                        <h3>Final Result</h3>
                        <div id="final-result">
                            <!-- Final result will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- <div style="flex: 1;">
                <div class="card">
                    <h2 class="card-title">Solutions</h2>
                    <div id="solutions-container">
                        <div class="solution-card">
                            <div class="solution-header">Enter parameters and run the algorithm to see solutions</div>
                            <div class="solution-content">Results will appear here after calculation.</div>
                        </div>
                    </div>
                    
                    <div class="pagination">
                        <div class="page-btn active">1</div>
                    </div>
                </div>
            </div> -->
        </div>
    </div>

    <script>
        // Global variables to store algorithm state
        let currentStep = 1;
        const totalSteps = 8;
        let supportPoints = [];
        let startingPoint = [];
        let directionVector = [];
        let normalizedDirection = [];
        let stepLength = 0;
        let newPoint = [];
        let secondMovementPoint = [];
        let objectiveValues = {};
        let solutions = [];
        let numVariables = 2;
        let numConstraints = 4;
        let constraintForStepLength = 0;

        // DOM elements
        const stepContents = document.querySelectorAll('.step-content');
        const stepIndicator = document.getElementById('step-indicator');
        const prevButton = document.getElementById('step-prev');
        const nextButton = document.getElementById('step-next');
        const runButton = document.getElementById('run-algorithm');
        const clearButton = document.getElementById('clear-all');
       // const loadExampleButton = document.getElementById('load-example');
        const updateVariablesBtn = document.getElementById('update-variables');
        const updateConstraintsBtn = document.getElementById('update-constraints');
        const numSupportPointsSelect = document.getElementById('num-support-points');
        const supportPointsContainer = document.getElementById('support-points-container');
        const supportPointsRange = document.getElementById('support-points-range');
        const constraintsContainer = document.getElementById('constraints');

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Set up event listeners
            prevButton.addEventListener('click', goToPrevStep);
            nextButton.addEventListener('click', goToNextStep);
            runButton.addEventListener('click', runAlgorithm);
            clearButton.addEventListener('click', clearAllFields);
            //loadExampleButton.addEventListener('click', loadExample);
            updateVariablesBtn.addEventListener('click', updateVariableInputs);
            updateConstraintsBtn.addEventListener('click', updateConstraintInputs);
            numSupportPointsSelect.addEventListener('change', updateSupportPointsInputs);
            
            // Initialize with default values
            updateVariableInputs();
            updateConstraintInputs();
        });

        function updateVariableInputs() {
            numVariables = parseInt(document.getElementById('num-variables').value) || 2;
            const objectiveContainer = document.getElementById('objective-coeffs');
            objectiveContainer.innerHTML = '';
            
            for (let i = 1; i <= numVariables; i++) {
                const div = document.createElement('div');
                div.className = 'input-group';
                div.innerHTML = `
                    <label for="c${i}">Coefficient for x${i}</label>
                    <input type="number" id="c${i}" placeholder="Enter coefficient">
                `;
                objectiveContainer.appendChild(div);
            }
            
            // Update support points range and options
            const minPoints = 2 * (numVariables + 1);
            const maxPoints = numVariables * (numVariables + 1) + 2;
            
            // Update the select options
            numSupportPointsSelect.innerHTML = '';
            for (let i = minPoints; i <= maxPoints; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                numSupportPointsSelect.appendChild(option);
            }
            
            // Set default to the minimum
            numSupportPointsSelect.value = minPoints;
            
            supportPointsRange.textContent = `For n=${numVariables}, the number of support points must be between ${minPoints} and ${maxPoints}.`;
            
            updateSupportPointsInputs();
        }

        function updateConstraintInputs() {
            numConstraints = parseInt(document.getElementById('num-constraints').value) || 4;
            constraintsContainer.innerHTML = '';
            
            for (let i = 0; i < numConstraints; i++) {
                addConstraintRow(i);
            }
        }

        function addConstraintRow(index) {
            const constraintRow = document.createElement('div');
            constraintRow.className = 'constraint-row';
            
            let constraintHTML = '';
            for (let j = 1; j <= numVariables; j++) {
                if (j > 1) {
                    constraintHTML += `<span>+</span>`;
                }
                constraintHTML += `
                    <input type="number" class="coefficient-input" placeholder="Value" id="a${index+1}${j}">
                    <span class="variable-label">x${j}</span>
                `;
            }
            
            constraintHTML += `
                <select class="operator-select" id="op${index+1}">
                    <option value="<=">≤</option>
                    <option value="=" selected>=</option>
                    <option value=">=">≥</option>
                </select>
                <input type="number" class="rhs-input" placeholder="RHS" id="b${index+1}">
            `;
            
            constraintRow.innerHTML = constraintHTML;
            constraintsContainer.appendChild(constraintRow);
        }

        function updateSupportPointsInputs() {
            const numPoints = parseInt(numSupportPointsSelect.value) || 6;
            const minPoints = 2 * (numVariables + 1);
            const maxPoints = numVariables * (numVariables + 1) + 2;
            
            // Validate input
            if (numPoints < minPoints) numSupportPointsSelect.value = minPoints;
            if (numPoints > maxPoints) numSupportPointsSelect.value = maxPoints;
            
            supportPointsContainer.innerHTML = '';
            
            // Create table for support points
            const table = document.createElement('table');
            
            // Create header row
            let headerRow = '<tr><th>Point</th><th>x₀</th>';
            for (let i = 1; i <= numVariables; i++) {
                headerRow += `<th>x${i}</th>`;
            }
            headerRow += '</tr>';
            table.innerHTML = headerRow;
            
            // Create data rows
            for (let i = 0; i < numPoints; i++) {
                let row = `<tr><td>${i+1}</td>`;
                row += `<td><input type="number" class="support-point-input" value="1" readonly></td>`;
                
                for (let j = 1; j <= numVariables; j++) {
                    row += `<td><input type="number" class="support-point-input" placeholder="Value" value="${Math.floor(Math.random() * 10) + 1}"></td>`;
                }
                
                row += '</tr>';
                table.innerHTML += row;
            }
            
            supportPointsContainer.appendChild(table);
        }

        function goToPrevStep() {
            if (currentStep > 1) {
                stepContents[currentStep - 1].classList.remove('active');
                currentStep--;
                stepContents[currentStep - 1].classList.add('active');
                updateStepIndicator();
                
                // Enable next button if we're not at the last step
                nextButton.disabled = false;
                
                // Disable prev button if we're at the first step
                prevButton.disabled = currentStep === 1;
            }
        }

        function goToNextStep() {
            if (currentStep < totalSteps) {
                stepContents[currentStep - 1].classList.remove('active');
                currentStep++;
                stepContents[currentStep - 1].classList.add('active');
                updateStepIndicator();
                
                // Enable prev button if we're not at the first step
                prevButton.disabled = false;
                
                // Disable next button if we're at the last step
                if (currentStep === totalSteps) {
                    nextButton.disabled = true;
                }
            }
        }

        function updateStepIndicator() {
            const stepTitles = [
                "Step 1: Initial Design Matrix",
                "Step 2: Optimal Starting Point",
                "Step 3: Direction of Movement",
                "Step 4: Optimal Step Length",
                "Step 5: First Movement",
                "Step 6: Termination Citeria",
                "Step 7: Second Movement",
                "Step 8: Final Result"
            ];
            stepIndicator.textContent = stepTitles[currentStep - 1];
        }

        function runAlgorithm() {
            // Reset steps
            currentStep = 1;
            stepContents.forEach((content, index) => {
                content.classList.toggle('active', index === 0);
            });
            updateStepIndicator();
            prevButton.disabled = true;
            nextButton.disabled = false;
            
            // Get problem parameters
            const problemType = document.getElementById('problem-type').value;
            // const numSolutions = parseInt(document.getElementById('num-solutions').value) || 5;
            
            // Get objective coefficients
            const c = [];
            for (let i = 1; i <= numVariables; i++) {
                const value = parseFloat(document.getElementById(`c${i}`).value);
                if (isNaN(value)) {
                    showError(`Please enter a valid coefficient for x${i}`);
                    return;
                }
                c.push(value);
            }
            
            // Get constraints
            const constraints = [];
            
            for (let i = 1; i <= numConstraints; i++) {
                const coefficients = [];
                for (let j = 1; j <= numVariables; j++) {
                    const value = parseFloat(document.getElementById(`a${i}${j}`).value);
                    if (isNaN(value)) {
                        showError(`Please enter a valid coefficient in constraint ${i} for x${j}`);
                        return;
                    }
                    coefficients.push(value);
                }
                
                const operator = document.getElementById(`op${i}`).value;
                const rhs = parseFloat(document.getElementById(`b${i}`).value);
                if (isNaN(rhs)) {
                    showError(`Please enter a valid right-hand side value in constraint ${i}`);
                    return;
                }
                
                constraints.push({
                    coefficients: coefficients,
                    operator: operator,
                    rhs: rhs
                });
            }
            
            // Get support points
            supportPoints = [];
            const supportPointInputs = document.querySelectorAll('.support-point-input');
            const numPoints = parseInt(numSupportPointsSelect.value);
            
            for (let i = 0; i < numPoints; i++) {
                const point = [1]; // x0 is always 1
                const startIndex = i * (numVariables + 1) + 1; // Skip the first column (x0)
                
                for (let j = 0; j < numVariables; j++) {
                    const value = parseFloat(supportPointInputs[startIndex + j].value);
                    if (isNaN(value)) {
                        showError(`Please enter a valid value for support point ${i+1}, x${j+1}`);
                        return;
                    }
                    point.push(value);
                }
                
                supportPoints.push(point);
            }
            
            // Run the algorithm
            executeAlgorithmSteps(numVariables, constraints.length, c, constraints, problemType);
        }

        function showError(message) {
            // Create error message
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            
            // Insert at the top of the problem definition card
            const card = document.querySelector('.card');
            const firstChild = card.firstChild;
            card.insertBefore(errorDiv, firstChild);
            
            // Remove error after 5 seconds
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }

        function executeAlgorithmSteps(n, m, c, constraints, problemType) {
            // Step 1: Initial Design Matrix
            displayInitialDesignMatrix(n);
            
            // Step 2: Optimal Starting Point
            calculateStartingPoint(n);
            
            // Step 3: Direction of Movement
            calculateDirectionVector(c, n);
            
            // Step 4: Optimal Step Length
            calculateStepLength(constraints, problemType, n);
            
            // Step 5: First Movement
            calculateFirstMovement(n);
            
            // Step 6: Termination Check
            const shouldContinue = checkTermination(c, n);
            
            // Step 7: Second Movement if needed
            if (shouldContinue) {
                calculateSecondMovement(constraints, n);
            } else {
                // Skip to final result if terminated
                currentStep = 8;
                stepContents[6].classList.remove('active');
                stepContents[7].classList.add('active');
                updateStepIndicator();
                prevButton.disabled = false;
                nextButton.disabled = true;
            }
            
            // Step 8: Final Result
            displayFinalResult(c, problemType, n);
            
            // Generate solutions
            // generateSolutions(c, problemType);
        }

        function displayInitialDesignMatrix(n) {
            let tableHTML = `<table>
                <tr>
                    <th>Point</th>
                    <th>x₀</th>`;
            
            for (let i = 1; i <= n; i++) {
                tableHTML += `<th>x${i}</th>`;
            }
            
            tableHTML += `</tr>`;
            
            supportPoints.forEach((point, index) => {
                tableHTML += `<tr><td>${index + 1}</td>`;
                point.forEach(value => {
                    tableHTML += `<td>${value.toFixed(4)}</td>`;
                });
                tableHTML += `</tr>`;
            });
            
            tableHTML += `</table>`;
            document.getElementById('initial-design-matrix').innerHTML = tableHTML;
            
            // Calculation details
            const minPoints = 2 * (n + 1);
            const maxPoints = n * (n + 1) + 2;
            
            document.getElementById('initial-design-calculation').textContent = 
                `We have chosen ${supportPoints.length} support points that satisfy all constraints. 
                For n=${n}, we need between ${minPoints} and ${maxPoints} points. 
                We are using ${supportPoints.length} support points for this problem.`;
        }

        function calculateStartingPoint(n) {
            // Calculate a_m = x_m * x_m' for each point
            const a = supportPoints.map(point => {
                // For a row vector x, a = x * x' (dot product)
                return point.reduce((sum, value) => sum + value * value, 0);
            });
            
            // Calculate a_m^{-1}
            const aInverse = a.map(value => 1 / value);
            
            // Calculate sum of a_m^{-1}
            const sumAInverse = aInverse.reduce((sum, value) => sum + value, 0);
            
            // Calculate u_m* = a_m^{-1} / sum(a_m^{-1})
            const uStar = aInverse.map(value => value / sumAInverse);
            
            // Calculate optimal starting point x_1* = Σ(u_m* * x_m)
            startingPoint = new Array(n + 1).fill(0);
            for (let i = 0; i < supportPoints.length; i++) {
                for (let j = 0; j < n + 1; j++) {
                    startingPoint[j] += uStar[i] * supportPoints[i][j];
                }
            }
            
            // Display calculation details
            let calculationText = `Calculate a_m = x_m * x_m' for each point:\n`;
            for (let i = 0; i < supportPoints.length; i++) {
                calculationText += `a_${i+1} = [${supportPoints[i].join(', ')}] * [${supportPoints[i].join(', ')}]' = ${a[i].toFixed(4)}\n`;
            }
            
            calculationText += `\nCalculate a_m^{-1}:\n`;
            for (let i = 0; i < supportPoints.length; i++) {
                calculationText += `a_${i+1}^{-1} = ${aInverse[i].toFixed(6)}\n`;
            }
            
            calculationText += `\nSum of a_m^{-1} = ${sumAInverse.toFixed(6)}\n\n`;
            
            calculationText += `Calculate u_m* = a_m^{-1} / sum(a_m^{-1}):\n`;
            for (let i = 0; i < supportPoints.length; i++) {
                calculationText += `u_${i+1}* = ${aInverse[i].toFixed(6)} / ${sumAInverse.toFixed(6)} = ${uStar[i].toFixed(6)}\n`;
            }
            
            calculationText += `\nCalculate optimal starting point x_1* = Σ(u_m* * x_m):\n`;
            calculationText += `x_1* = \n`;
            for (let i = 0; i < supportPoints.length; i++) {
                calculationText += `${uStar[i].toFixed(6)} * [${supportPoints[i].join(', ')}]${i < supportPoints.length - 1 ? ' +' : ''}\n`;
            }
            
            // Format the starting point for display (skip x0)
            const startingPointDisplay = startingPoint.slice(1).map(v => v.toFixed(6));
            calculationText += `= [${startingPointDisplay.join(', ')}]`;
            
            document.getElementById('starting-point-calculation').textContent = calculationText;
            
            // Display result
            document.getElementById('starting-point-result').innerHTML = `
                <p class="result">Optimal starting point: x₁* = [${startingPointDisplay.join(', ')}]</p>
            `;
        }

        function calculateDirectionVector(c, n) {
            // The direction vector is the same as the gradient of the objective function
            directionVector = c;
            
            // Normalize the direction vector
            const magnitude = Math.sqrt(directionVector.reduce((sum, value) => sum + value * value, 0));
            normalizedDirection = directionVector.map(value => value / magnitude);
            
            // Display calculation details
            let calculationText = `Direction vector d = gradient of objective function = [${c.join(', ')}]\n\n`;
            calculationText += `Normalize d such that d*'d* = 1:\n`;
            
            const squaredTerms = c.map(v => `${v}²`).join(' + ');
            const squaredSum = c.reduce((sum, v) => sum + v*v, 0);
            
            calculationText += `||d|| = sqrt(${squaredTerms}) = sqrt(${squaredSum}) = ${magnitude.toFixed(6)}\n\n`;
            calculationText += `d* = [${c.join(', ')}] / ${magnitude.toFixed(6)} = [${normalizedDirection.map(v => v.toFixed(6)).join(', ')}]`;
            
            document.getElementById('direction-calculation').textContent = calculationText;
            
            // Display result
            document.getElementById('direction-result').innerHTML = `
                <p class="result">Direction vector: d = [${directionVector.join(', ')}]</p>
                <p class="result">Normalized direction vector: d* = [${normalizedDirection.map(v => v.toFixed(6)).join(', ')}]</p>
            `;
        }

        function calculateStepLength(constraints, problemType, n) {
            // For each constraint, calculate (A_i x_1* - b_i) / (A_i d*)
            const stepLengths = [];
            
            for (let i = 0; i < constraints.length; i++) {
                const constraint = constraints[i];
                
                // Calculate A_i x_1* (skip x0)
                let Ax = 0;
                for (let j = 0; j < n; j++) {
                    Ax += constraint.coefficients[j] * startingPoint[j + 1];
                }
                
                // Calculate A_i d*
                let Ad = 0;
                for (let j = 0; j < n; j++) {
                    Ad += constraint.coefficients[j] * normalizedDirection[j];
                }
                
                // Calculate (A_i x_1* - b_i) / (A_i d*)
                const rho = (Ax - constraint.rhs) / Ad;
                
                stepLengths.push({
                    constraint: i + 1,
                    Ax: Ax,
                    Ad: Ad,
                    rho: rho
                });
            }
            
            // For maximization, choose the maximum rho; for minimization, choose the minimum
            let optimalRho;
            if (problemType === 'max') {
                optimalRho = Math.max(...stepLengths.map(item => item.rho));
                constraintForStepLength = stepLengths.findIndex(item => item.rho === optimalRho) + 1;
            } else {
                optimalRho = Math.min(...stepLengths.map(item => item.rho));
                constraintForStepLength = stepLengths.findIndex(item => item.rho === optimalRho) + 1;
            }
            
            stepLength = optimalRho;
            
            // Display calculation details
            let calculationText = `For each constraint, calculate ρ₁* = (Aᵢ x₁* - bᵢ) / (Aᵢ d*):\n\n`;
            
            for (const item of stepLengths) {
                calculationText += `Constraint ${item.constraint}: ρ_${item.constraint}* = (${item.Ax.toFixed(4)} - ${constraints[item.constraint-1].rhs}) / ${item.Ad.toFixed(6)} = ${item.rho.toFixed(6)}\n`;
            }
            
            calculationText += `\nFor ${problemType === 'max' ? 'maximization' : 'minimization'}, choose ${problemType === 'max' ? 'max' : 'min'} ρ₁* = ${stepLength.toFixed(6)} (from constraint ${constraintForStepLength})`;
            
            document.getElementById('step-length-calculation').textContent = calculationText;
            
            // Display result
            document.getElementById('step-length-result').innerHTML = `
                <p class="result">Optimal step length: ρ₁* = ${stepLength.toFixed(6)}</p>
                <p class="result">This value comes from constraint ${constraintForStepLength}</p>
            `;
        }

        function calculateFirstMovement(n) {
            // Calculate new point: x_2* = x_1* - ρ*d* (skip x0)
            newPoint = [];
            for (let i = 1; i < startingPoint.length; i++) {
                newPoint.push(startingPoint[i] - stepLength * normalizedDirection[i - 1]);
            }
            
            // Display calculation details
            let calculationText = `Make a move to the  point:\n`;
            calculationText += `x₂* = x₁* - ρ₁*d*\n`;
            
            const startingPointDisplay = startingPoint.slice(1).map(v => v.toFixed(6));
            calculationText += `= [${startingPointDisplay.join(', ')}] - ${stepLength.toFixed(6)} * [${normalizedDirection.map(v => v.toFixed(6)).join(', ')}]\n`;
            calculationText += `= [${newPoint.map(v => v.toFixed(6)).join(', ')}]`;
            
            document.getElementById('movement-calculation').textContent = calculationText;
            
            // Display result
            document.getElementById('movement-result').innerHTML = `
                <p class="result">New point: x₂* = [${newPoint.map(v => v.toFixed(4)).join(', ')}]</p>
            `;
        }

        function checkTermination(c, n) {
            // Calculate objective values at x_1* and x_2*
            let f_x1 = 0;
            for (let i = 1; i < startingPoint.length; i++) {
                f_x1 += c[i - 1] * startingPoint[i];
            }
            
            let f_x2 = 0;
            for (let i = 0; i < newPoint.length; i++) {
                f_x2 += c[i] * newPoint[i];
            }
            
            objectiveValues = {
                f_x1: f_x1,
                f_x2: f_x2,
                difference: Math.abs(f_x2 - f_x1)
            };
            
            // Check if difference is less than epsilon
            const epsilon = 0.0001;
            const shouldTerminate = objectiveValues.difference < epsilon;
            
            // Display calculation details
            let calculationText = `Calculate f(x₂*) and f(x₁*):\n`;
            
            let f_x1Formula = '';
            for (let i = 0; i < n; i++) {
                f_x1Formula += `${c[i]} * ${startingPoint[i + 1].toFixed(6)}`;
                if (i < n - 1) f_x1Formula += ' + ';
            }
            
            let f_x2Formula = '';
            for (let i = 0; i < n; i++) {
                f_x2Formula += `${c[i]} * ${newPoint[i].toFixed(6)}`;
                if (i < n - 1) f_x2Formula += ' + ';
            }
            
            calculationText += `f(x₁*) = ${f_x1Formula} = ${f_x1.toFixed(6)}\n`;
            calculationText += `f(x₂*) = ${f_x2Formula} = ${f_x2.toFixed(6)}\n\n`;
            calculationText += `|f(x₂*) - f(x₁*)| = |${f_x2.toFixed(6)} - ${f_x1.toFixed(6)}| = ${objectiveValues.difference.toFixed(6)}\n\n`;
            calculationText += `Compare with ε = ${epsilon}: ${objectiveValues.difference.toFixed(6)} ${shouldTerminate ? '<' : '>'} ${epsilon}\n`;
            // calculationText += `Algorithm ${shouldTerminate ? 'should terminate' : 'should continue'}`;
            
            document.getElementById('termination-calculation').textContent = calculationText;
            
            // Display result
            // document.getElementById('termination-result').innerHTML = `
            //     <p class="result">f(x_1*) = ${f_x1.toFixed(4)}</p>
            //     <p class="result">f(x_2*) = ${f_x2.toFixed(4)}</p>
            //     <p class="result">Difference = ${objectiveValues.difference.toFixed(6)}</p>
            //     <p class="result">Algorithm ${shouldTerminate ? 'terminates' : 'continues to next iteration'}</p>
            // `;
            
            return !shouldTerminate;
        }

        function calculateSecondMovement(constraints, n) {
            // Use the constraint that gave the optimum step length in step 3
            const constraint = constraints[constraintForStepLength - 1];
            
            // Calculate A_i d*
            let Ad = 0;
            for (let j = 0; j < n; j++) {
                Ad += constraint.coefficients[j] * normalizedDirection[j];
            }
            
            // Calculate A_i x_2*
            let Ax = 0;
            for (let j = 0; j < n; j++) {
                Ax += constraint.coefficients[j] * newPoint[j];
            }
            
            // Calculate new step length ρ₂* = (A_i x_2* - b_i) / (A_i d*)
            const rho2 = (Ax - constraint.rhs) / Ad;
            
            // Calculate second movement point: x_3* = x_2* - ρ₂*d*
            secondMovementPoint = [];
            for (let i = 0; i < newPoint.length; i++) {
                secondMovementPoint.push(newPoint[i] - rho2 * normalizedDirection[i]);
            }
            
            // Display calculation details
            let calculationText = `\n`;
            calculationText += `Using constraint ${constraintForStepLength} that gave the optimum step length in step 3:\n\n`;
            
            calculationText += `Calculate new step length ρ₂* = (Aᵢ x₂* - bᵢ) / (Aᵢ d*)\n`;
            calculationText += `= (${Ax.toFixed(6)} - ${constraint.rhs}) / ${Ad.toFixed(6)}\n`;
            calculationText += `= ${rho2.toFixed(6)}\n\n`;
            
            // calculationText += `Make a move to the new point:\n`;
            // calculationText += `x3* = x₂* - ρ₂*d*\n`;
            // calculationText += `= [${newPoint.map(v => v.toFixed(6)).join(', ')}] - ${rho2.toFixed(6)} * [${normalizedDirection.map(v => v.toFixed(6)).join(', ')}]\n`;
            // calculationText += `= [${secondMovementPoint.map(v => v.toFixed(6)).join(', ')}]`;
            
            document.getElementById('second-movement-calculation').textContent = calculationText;
            
            // Display result
            document.getElementById('second-movement-result').innerHTML = `
                <p class="result"> since the New step length: ρ₂* = ${rho2.toFixed(6)}, then the optimizer had been located in step 5.</p>

              <!---   <p class="result">Second movement point: x3* = [${secondMovementPoint.map(v => v.toFixed(4)).join(', ')}]</p>-->
            `;
            
            // Update newPoint to be the second movement point for final result
            newPoint = secondMovementPoint;
        }

        function displayFinalResult(c, problemType, n) {
            let f_x2 = 0;
            for (let i = 0; i < newPoint.length; i++) {
                f_x2 += c[i] * newPoint[i];
            }
            
            document.getElementById('final-result').innerHTML = `
                <div class="result">
                    <h3>Optimal Solution Found</h3>
                    ${newPoint.map((val, idx) => `<p>x${idx+1}* = ${val.toFixed(4)}</p>`).join('')}
                    <p>Optimal ${problemType === 'max' ? 'Maximum' : 'Minimum'} Objective Function Value = ${f_x2.toFixed(4)}</p>
                </div>
                
                <div>
                    <h3>Verification with Constraints</h3>
                    <p>The solution satisfies all constraints (verified during support point selection).</p>
                </div>
            `;
        }

        // function generateSolutions(c, problemType, numSolutions) {
        //     solutions = [];
            
        //     // Solution 1: The calculated solution
        //     solutions.push({
        //         values: newPoint,
        //         objective: calculateObjectiveValue(c, newPoint)
        //     });
            
        //     // Generate additional solutions with small variations
        //     for (let i = 1; i < numSolutions; i++) {
        //         const variation = newPoint.map(v => v + (Math.random() * 2 - 1));
        //         solutions.push({
        //             values: variation,
        //             objective: calculateObjectiveValue(c, variation)
        //         });
        //     }
            
        //     // Sort solutions based on problem type
        //     if (problemType === 'max') {
        //         solutions.sort((a, b) => b.objective - a.objective);
        //     } else {
        //         solutions.sort((a, b) => a.objective - b.objective);
        //     }
            
        //     // Display solutions
        //     const solutionsContainer = document.getElementById('solutions-container');
        //     solutionsContainer.innerHTML = '';
            
        //     solutions.forEach((solution, index) => {
        //         const solutionCard = document.createElement('div');
        //         solutionCard.className = 'solution-card';
                
        //         let solutionText = '';
        //         solution.values.forEach((value, idx) => {
        //             solutionText += `x${idx+1} = ${value.toFixed(4)}\n`;
        //         });
        //         solutionText += `Objective Function Value: ${solution.objective.toFixed(4)}`;
                
        //         solutionCard.innerHTML = `
        //             <div class="solution-header">Solution #${index + 1}</div>
        //             <div class="solution-content">${solutionText}</div>
        //         `;
                
        //         solutionsContainer.appendChild(solutionCard);
        //     });
            
        //     // Update pagination
        //     const pagination = document.querySelector('.pagination');
        //     pagination.innerHTML = '';
            
        //     const totalPages = Math.ceil(solutions.length / 5);
        //     for (let i = 1; i <= totalPages; i++) {
        //         const pageBtn = document.createElement('div');
        //         pageBtn.className = 'page-btn' + (i === 1 ? ' active' : '');
        //         pageBtn.textContent = i;
        //         pageBtn.addEventListener('click', () => showSolutionPage(i));
        //         pagination.appendChild(pageBtn);
        //     }
        // }

        function calculateObjectiveValue(c, values) {
            let result = 0;
            for (let i = 0; i < c.length; i++) {
                result += c[i] * values[i];
            }
            return result;
        }

        // function showSolutionPage(pageNum) {
        //     const solutionsContainer = document.getElementById('solutions-container');
        //     solutionsContainer.innerHTML = '';
            
        //     const startIndex = (pageNum - 1) * 5;
        //     const endIndex = Math.min(startIndex + 5, solutions.length);
            
        //     for (let i = startIndex; i < endIndex; i++) {
        //         const solution = solutions[i];
        //         const solutionCard = document.createElement('div');
        //         solutionCard.className = 'solution-card';
                
        //         let solutionText = '';
        //         solution.values.forEach((value, idx) => {
        //             solutionText += `x${idx+1} = ${value.toFixed(4)}\n`;
        //         });
        //         solutionText += `Objective Function Value: ${solution.objective.toFixed(4)}`;
                
        //         solutionCard.innerHTML = `
        //             <div class="solution-header">Solution #${i + 1}</div>
        //             <div class="solution-content">${solutionText}</div>
        //         `;
                
        //         solutionsContainer.appendChild(solutionCard);
        //     }
            
        //     // Update active page button
        //     document.querySelectorAll('.page-btn').forEach((btn, index) => {
        //         btn.classList.toggle('active', index === pageNum - 1);
        //     });
        // }

        function clearAllFields() {
            // Clear problem type
            document.getElementById('problem-type').value = 'max';
            
            // Clear variables
            document.getElementById('num-variables').value = '2';
            numVariables = 2;
            
            // Clear constraints
            document.getElementById('num-constraints').value = '4';
            numConstraints = 4;
            
            // Clear solutions count
            document.getElementById('num-solutions').value = '5';
            
            // Clear objective coefficients
            const objectiveContainer = document.getElementById('objective-coeffs');
            objectiveContainer.innerHTML = '';
            
            // Reset to 2 variables
            updateVariableInputs();
            updateConstraintInputs();
            
            // Clear support points
            updateSupportPointsInputs();
            
            // Clear algorithm steps
            document.getElementById('initial-design-calculation').textContent = 
                'Enter your problem parameters and click "Run IPBA Algorithm" to see calculations.';
            document.getElementById('initial-design-matrix').innerHTML = '';
            document.getElementById('starting-point-calculation').textContent = '';
            document.getElementById('starting-point-result').innerHTML = '';
            document.getElementById('direction-calculation').textContent = '';
            document.getElementById('direction-result').innerHTML = '';
            document.getElementById('step-length-calculation').textContent = '';
            document.getElementById('step-length-result').innerHTML = '';
            document.getElementById('movement-calculation').textContent = '';
            document.getElementById('movement-result').innerHTML = '';
            document.getElementById('termination-calculation').textContent = '';
            document.getElementById('termination-result').innerHTML = '';
            document.getElementById('second-movement-calculation').textContent = '';
            document.getElementById('second-movement-result').innerHTML = '';
            document.getElementById('final-result').innerHTML = '';
            
            // Clear solutions
            // document.getElementById('solutions-container').innerHTML = `
            //     <div class="solution-card">
            //         <div class="solution-header">Enter parameters and run the algorithm to see solutions</div>
            //         <div class="solution-content">Results will appear here after calculation.</div>
            //     </div>
            // `;
            
            // Reset pagination
            document.querySelector('.pagination').innerHTML = '<div class="page-btn active">1</div>';
            
            // Reset steps
            currentStep = 1;
            stepContents.forEach((content, index) => {
                content.classList.toggle('active', index === 0);
            });
            updateStepIndicator();
            prevButton.disabled = true;
            nextButton.disabled = false;
        }

        // function loadExample() {
        //     // Set problem type
        //     document.getElementById('problem-type').value = 'max';
            
        //     // Set variables
        //     document.getElementById('num-variables').value = '2';
        //     numVariables = 2;
            
        //     // Set constraints
        //     document.getElementById('num-constraints').value = '4';
        //     numConstraints = 4;
            
        //     // Set solutions count
        //     document.getElementById('num-solutions').value = '5';
            
        //     // Update UI
        //     updateVariableInputs();
        //     updateConstraintInputs();
            
        //     // Set objective coefficients
        //     document.getElementById('c1').value = '850';
        //     document.getElementById('c2').value = '350';
            
        //     // Set constraints
        //     document.getElementById('a11').value = '8';
        //     document.getElementById('a12').value = '5';
        //     document.getElementById('b1').value = '200';
            
        //     document.getElementById('a21').value = '4';
        //     document.getElementById('a22').value = '1';
        //     document.getElementById('b2').value = '48';
            
        //     document.getElementById('a31').value = '5';
        //     document.getElementById('a32').value = '4';
        //     document.getElementById('b3').value = '80';
            
        //     document.getElementById('a41').value = '3';
        //     document.getElementById('a42').value = '5';
        //     document.getElementById('b4').value = '150';
            
        //     // Set support points to 8
        //     numSupportPointsSelect.value = '8';
        //     updateSupportPointsInputs();
            
        //     // Set specific support points from the example
        //     const supportPoints = [
        //         [1, 10, 7],
        //         [1, 8, 8],
        //         [1, 7, 4],
        //         [1, 6, 8],
        //         [1, 5, 7],
        //         [1, 9, 4],
        //         [1, 4, 6],
        //         [1, 11, 3]
        //     ];
            
        //     const supportPointInputs = document.querySelectorAll('.support-point-input');
        //     for (let i = 0; i < supportPoints.length; i++) {
        //         const point = supportPoints[i];
        //         const startIndex = i * (numVariables + 1) + 1;
                
        //         for (let j = 0; j < numVariables; j++) {
        //             supportPointInputs[startIndex + j].value = point[j + 1];
        //         }
        //     }
        // }
    </script>
</body>
</html>
